# ES6标准入门
## let和const，块级作用域

let & const
- 存在块级作用域。
- 不存在变量提升。
- 先声明在使用，否则报错。在作用域开始到let变量声明之间存在暂时性死区（TDZ）
- 不可以重复定义，否则报错。

const
- 只声明不赋值，报错。
- 一旦声明，值就不可以改变。本质是内存地址不可变，如果是赋值一个对象，则对象是可以操作的。只是不能重新指向其他对象或者赋值其他基础类型。如果想对象也不会被操作。则需要用Object.freeze({})冻结对象，但是此方法只冻结一层。也就是说如果被冻结的对象属性也是个对象，则可以操作这个对象属性。

### 块级作用域
- 允许块级做用户任意嵌套
- 内外层的块定了let变量互不影响。也就是不同块可以定义相同的变量名
- 允许块级作用域用function声明函数，但是定义的的函数类似var，函数名称会提升到函数作用域头部或提升到全局头部，同时函数体会提成到块级作用域头部
#### do表达式，

一个可以返回值的块级作用域。
一般块级作用域就是一个语句，将多个操作封装在一起用一对大括号{}，没有返回值。
(提案中)如果想返回则在大括号前，加个do。例如let a = do{}

## 变量的结构赋值（Destructuring）

ES6允许按照一定的模式从数组和对象中提取值，然后对变量进行赋值，这被称为结构赋值。
### 数组解构赋值、
- 按照数组的位置对应进行赋值
- 完全解构，不完全解构
- 解构赋值可以嵌套
- 解构不成功，变量赋值undefined
- 只有实现了Iterator的对象才能进行数组形式的解构赋值
- 解构赋值，可以设置默认值（严格判断取值是不是===undefined，才启用默认值）。如果默认值是表达式，则这个表达式是惰性求值的，只有用到了才会运算求职。
- 解构赋值可以用到解构赋值中的其他的变量，前提是其他变量在被引用之前已经被证明了。
### 对象的解构赋值
- 按照属性的名称对应进行赋值
- 可以嵌套
- 可以指定默认值（属性严格===undefined）
- 解构不成功，变量赋值undefined
### 字符串解构赋值

可以像数组一样取值，赋值。

### 数字和布尔值的结构赋值

先把数字和布尔值转化成对象，再按照对象的解构赋值进行操作

解构赋值的规则是，只要等号右边不是对象或者数组，都要将其转化成对象。
undefined和null不能转换为对象，对它们解构赋值的时候会报错。
### 函数的参数解构赋值
按照解构赋值灵活掌握.

## 字符串
### codePointAt (es6)识别32位UTF-16的字符
### String.formCodePoint (es6)识别32位UTF-16
