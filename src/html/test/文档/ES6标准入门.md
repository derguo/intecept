# ES6标准入门
## let和const，块级作用域

let & const
- 存在块级作用域。
- 不存在变量提升。
- 先声明在使用，否则报错。在作用域开始到let变量声明之间存在暂时性死区（TDZ）
- 不可以重复定义，否则报错。

const
- 只声明不赋值，报错。
- 一旦声明，值就不可以改变。本质是内存地址不可变，如果是赋值一个对象，则对象是可以操作的。只是不能重新指向其他对象或者赋值其他基础类型。如果想对象也不会被操作。则需要用Object.freeze({})冻结对象，但是此方法只冻结一层。也就是说如果被冻结的对象属性也是个对象，则可以操作这个对象属性。

### 块级作用域
- 允许块级做用户任意嵌套
- 内外层的块定了let变量互不影响。也就是不同块可以定义相同的变量名
- 允许块级作用域用function声明函数，但是定义的的函数类似var，函数名称会提升到函数作用域头部或提升到全局头部，同时函数体会提成到块级作用域头部
#### do表达式，

一个可以返回值的块级作用域。
一般块级作用域就是一个语句，将多个操作封装在一起用一对大括号{}，没有返回值。
(提案中)如果想返回则在大括号前，加个do。例如let a = do{}

## 变量的结构赋值（Destructuring）

ES6允许按照一定的模式从数组和对象中提取值，然后对变量进行赋值，这被称为结构赋值。
### 数组解构赋值、
- 按照数组的位置对应进行赋值
- 完全解构，不完全解构
- 解构赋值可以嵌套
- 解构不成功，变量赋值undefined
- 只有实现了Iterator的对象才能进行数组形式的解构赋值
- 解构赋值，可以设置默认值（严格判断取值是不是===undefined，才启用默认值）。如果默认值是表达式，则这个表达式是惰性求值的，只有用到了才会运算求职。
- 解构赋值可以用到解构赋值中的其他的变量，前提是其他变量在被引用之前已经被证明了。
### 对象的解构赋值
- 按照属性的名称对应进行赋值
- 可以嵌套
- 可以指定默认值（属性严格===undefined）
- 解构不成功，变量赋值undefined
### 字符串解构赋值

可以像数组一样取值，赋值。

### 数字和布尔值的结构赋值

先把数字和布尔值转化成对象，再按照对象的解构赋值进行操作

解构赋值的规则是，只要等号右边不是对象或者数组，都要将其转化成对象。
undefined和null不能转换为对象，对它们解构赋值的时候会报错。
### 函数的参数解构赋值
按照解构赋值灵活掌握.

## 字符串
### codePointAt (es6)识别32位UTF-16的字符

codePointAt是字符串的方法
### String.formCodePoint (es6)识别32位UTF-16

formCodePoint是在String上的静态方法
### 字符串遍历器接口

for...of循环，可以识别大于0xFFFF的码点（32位UTF-16编码）

### includes(),startWith(),endWith()

都返回布尔值，都有两个参数。
- includes()是否包含第一个参数字符串，第二个参数表示从哪个位置开始查找
- startWith()表示第一个参数是否出现在被查询字符串的开始位置，第二个参数是表示从哪个位置开始查找
- endWith()表示第一个参数是否出现在被查询字符串的结束位置，第二个参数表示在前几个字符中查找

### repeat()

返回一个新字符串，表示将原字符串重复n次
- 参数为小数，取整（1.9 取整为 1）
- 参数为复数或者Infinity（无穷）报错
- 参数为NaN，相当于0
- 参数为1> n > -1的小数取整，相当于0（0.9取整为0，-0.9取整为-0，repeat视为0）
- 参数为字符串，将字符串转换为数字（字符转数字，要么NaN要么是数字）

### padEnd(), padstart()

返回一个新字符串，如果字符串不够第一个参数指定的长度，则用第二个参数字符串在字符串开始或者结尾补全
- 第一参数为指定长度，第二参数用来补全长度
- 补全字符串长度不够，则重复不全字符串直到填满
- 补全字符串长度超过所需，则截取需要的长度补在字符串开始或结束位置
- 字符串长度等于或者大于指定长度，则返回这个字符串
- 第二参数为空，则用空格补全

### 字符串模板

用反引号``括起来的字符
- 可以保留格式
- 可以引用变量，用${}
- 可以引用表达式，用${}，但是仅是表达式而已，定义变量不行
- 可以嵌套其他模板字符串
- 

