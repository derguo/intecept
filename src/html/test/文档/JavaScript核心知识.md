# JavaScript核心
### 基础数据结构
##### 栈stack（后进先出--LIFO，last in first out）
栈可以看作一个按照顺序排列的消息数据（事件）集合。

这个集合可以看作是一个内部嵌套了一个方法的函数，
而这个内部方法又嵌套了一个方法，就这么嵌套了N层。
当执行这个方法时，需要先执行内部的方法，也就是要先执行最内部的方法，然后就是等内部的一层层方法按照嵌套层级的反向顺序执行完毕，才能执行最外层的方法。

所以当你执行这么一个方法（栈）时，就是要先执行“最后来的方法”，所以叫做先进后出。


JavaScript是单线程语言，主线程执行同步代码。 
函数调用时， 便会在内存中形成了一个“调用记录”， 又称“调用帧”， 保存调用位置和内部变量等信息。 如果函数内部还调用了其他函数，那么在调用记录上方又会形成一个调用记录， 所有的调用记录就形成一个“调用栈”。（闭包、尾调用、尾递归优化）
##### 堆heap
堆是指一块已分配的用来存储所需数据的存储空间（内存）。

对象的值被分配在一个堆中，并用一个地址记录该值存储的位置，
这个地址存储在命名对象的变量（内存，也可以说栈内存）中。
所以复制这个变量只是复制了引用地址，而不是复制了这个对象。
##### 队列queue（先进先出--FIFO，first in first out）
队列也可以看作是指一个按照顺序排列的消息事件集合。

区别就是队列像一个直线单向传送带，先传送到终点的物品，先进行处理。
### 内存空间
##### 基础数据类型与变量
基础数据类型6种，undefined null String Number Boolen Symbol
函数运行时，会创建一个执行环境，这个执行环境叫做执行上下文（Execution Context）在执行上下文中，会创建一个变量对象（VO），基础数据类型就保存在变量对象中。
##### 引用数据类型与堆内存空间
引用数据类型的值是存储在堆内存空间中的对象，在js中不允许访问堆内存中的数据，因此不能直接操作对象的堆内存空间。在操作时，实际上是操作对象的引用而不是实际对象。
##### 内存空间管理
JavaScript不用直接分配内存呢，有垃圾回收机制。

JavaScript 的垃圾回收实现主要依靠“引用”的概念 当一块内存空间中的数据能够被访问时，垃圾回收器就认为“该数据能够被获得”。不能够被获得的数据，就会被打上标记，并回收内存空间。这种方式叫作：标记-清除算法
### 执行上下文
##### 执行上下文三种情况
- 全局环境：代码开始运行首先会进入全局环境。
- 函数环境：当函数被调用执行时，会进入当前函数中的执行代码。
- eval环境：效率低下不建议使用。
##### 执行上下文的生命周期
两个阶段：
1. 创建阶段
2. 执行阶段

![执行上下文的生命周期](./img/1.png)

### 变量对象

变量对象包含内容：

1. 函数所有参数（Firefox为单独的参数对象arguments）
2. 当前上下文中所有的函数声明。（function定义的，能提升的函数）
3. 当前上下文中的所有变量声明。（通过var声明的变量）

##### 变量对象的创建过程

### 作用域与作用域链
### 闭包
### this
### 变量对象