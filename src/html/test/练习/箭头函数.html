<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        console.log();
        var func = function(params) {console.log(this)}

        var func1 = () => {console.log(this);}

        var obj = {
            f(){
                console.log(this);
            },
            f1:() => {console.log(this);},
            f2:function(){

            },
            f3:function f3(){

            },
            func1,
        }

        var ooo = {}

        // console.log(new func());
        // console.log(new func1());
        // console.log(new obj.f1());
        // console.log(new obj.f3());
        
        // obj.f1();
        // obj.f();
        //new obj.f(); //报错not a constructor
        // obj.f.bind(null)();

        // var objf = obj.f
        // objf();
        // new objf();

        // new obj.f2()

        // obj.func1();

        // obj.f1.bind(ooo)()

        // func1.bind(ooo)();

        /**
         *  1.箭头函数不能被bind,bind后this不变
         *  2.箭头函数不能new
         * */
        

        // new obj.f();
        /**
         *  字面量定义对象中直接xxx()像这样定义的函数
         * 1.不能被new，因为没有构造函数
         * 2.不像箭头函数那this绑定对象所在的上下文 
         * 3.谁调用this指向谁
         * 4.可以bind其他对象
        */
        // obj.f();
        // ooo.f = obj.f;
        // ooo.f();
        // new ooo.f();
        // obj.f.bind(ooo)()
        // console.log(obj.f.prototype.constructor) // 没有构造哦函数所以不能new

        // console.log(func.prototype.constructor);

        /* console.log("箭头函数的this是上下文的this");
        //箭头函数的this是上下文的this
        function foo(){
            let bar = ()=>{
                console.log(this);
            }
            bar()
        }
        foo()
        foo.call(ooo) */
    </script> 
</body>

</html>